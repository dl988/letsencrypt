#!/usr/bin/env php
<?php

use League\CLImate\CLImate;
use Imbrish\LetsEncrypt\Command;
use Symfony\Component\Yaml\Yaml;
use Symfony\Component\Yaml\Exception\ParseException;

// define exit codes

const EX_SUCCESS               = 0;
const EX_AUTOLOAD_NOT_FOUND    = 1;
const EX_OPENSSL_NOT_FOUND     = 2;
const EX_SAPI_INVALID          = 3;
const EX_CONFIG_NOT_FOUND      = 4;
const EX_CONFIG_PARSING_ERROR  = 5;
const EX_PROCESSING_ERROR      = 6;
const EX_CONFIG_INVALID        = 7;
const EX_AUTOLOAD_OUTDATED     = 8;
const EX_NAMESERVER_HACK_ERROR = 11;

// define paths

$config['base'] = realpath(__DIR__ . '/..');
$config['storage'] = $config['base'] . '/storage';

// check and require composer autoloader

$message = "You need to install the composer dependencies, please run 'composer install'!" . PHP_EOL;

if (! file_exists($config['base'] . '/vendor/autoload.php')) {
    echo $message;
    exit(EX_AUTOLOAD_NOT_FOUND);
}

$stored = file_exists($path = $config['storage'] . '/composer.hash') ? file_get_contents($path) : false;
$actual = file_exists($path = $config['base'] . '/composer.json') ? md5(file_get_contents($path)) : false;

if (! $stored || $stored !== $actual) {
    echo $message;
    exit(EX_AUTOLOAD_OUTDATED);
}

require $config['base'] . '/vendor/autoload.php';

// initialize CLImate

$climate = new CLImate;

// correctly detect ANSI support when using shell on Windows

if (getenv('ANSICON') !== false) {
    $climate->forceAnsiOn();
}

// check the environment

if (! function_exists('openssl_pkey_get_private')) {
	$climate->to('error')->error('You need to enable OpenSSL in your php.ini!');
    exit(EX_OPENSSL_NOT_FOUND);
}

if (! in_array(PHP_SAPI, ['cli', 'phpdbg'], true)) {
    $climate->to('error')->error('Please run this script on the command line!');
    exit(EX_SAPI_INVALID);
}

// register custom error handler

ini_set('display_errors', '1');

set_error_handler(function ($severity, $message, $file, $line, $context) {
    global $climate;

    if (! (error_reporting() & $severity)) {
        return false;
    }

    static $labels = [
        E_ERROR             => 'Error',
        E_WARNING           => 'Warning',
        E_PARSE             => 'Parse',
        E_NOTICE            => 'Notice',
        E_CORE_ERROR        => 'Core Error',
        E_CORE_WARNING      => 'Core Warning',
        E_COMPILE_ERROR     => 'Compile Error',
        E_COMPILE_WARNING   => 'Compile Warning',
        E_USER_ERROR        => 'User Error',
        E_USER_WARNING      => 'User Warning',
        E_USER_NOTICE       => 'User Notice',
        E_STRICT            => 'Strict',
        E_RECOVERABLE_ERROR => 'Recoverable Error',
        E_DEPRECATED        => 'Deprecated',
        E_USER_DEPRECATED   => 'User Deprecated',
    ];

    $label = $labels[$severity] ?: "Error ($severity)";

    $climate->to('error')->shout("$label: $message in $file on line $line");

    return true;
});

// define and parse arguments

$climate->description('Automatic issuing and renewal of Let\'s Encrypt SSL certificates on shared hostings');

$climate->arguments->add([
    'notify' => [
        'prefix'       => 'n',
        'longPrefix'   => 'notify',
        'description'  => 'Send email notification about errors or issued certificates',
    ],
    'config' => [
        'prefix'       => 'c',
        'longPrefix'   => 'config',
        'description'  => 'Name of the configuration file including extension',
        'defaultValue' => 'config.yml',
    ],
    'help' => [
        'prefix'       => 'h',
        'longPrefix'   => 'help',
        'description'  => 'Display this help message',
        'noValue'      => true,
    ],
    'certificates' => [
        'description'  => 'Common names of certificates to issue and install',
    ],
]);

$climate->arguments->parse();

// extract certificates argument manually to allow multiple names

$skipNextAfter = [];

foreach ($climate->arguments->all() as $argument) {
    if ($argument->noValue()) {
        continue;
    }

    if ($prefix = $argument->prefix()) {
        $skipNextAfter[] = '-'.$prefix;
    }

    if ($prefix = $argument->longPrefix()) {
        $skipNextAfter[] = '--'.$prefix;
    }
}

$certificates = [];
$skipNext = false;

for ($i = 1; $i < count($argv); $i++) {
    if (in_array($argv[$i], $skipNextAfter)) {
        $skipNext = true;
    }
    else if ($argv[$i] === '--') {
        $certificates = [];
        $skipNext = false;
    }
    else if ($skipNext) {
        $skipNext = false;
    }
    else if (substr($argv[$i], 0, 1) !== '-') {
        $certificates[] = $argv[$i];
    }
}

// fix incorrect values of options followed by another option

foreach ($climate->arguments->all() as $argument) {
    if (! $argument->hasPrefix() || $argument->noValue()) {
        continue;
    }

    if (substr($argument->value(), 0, 1) === '-') {
        $argument->setValue(null);
    }
}

// display the help message

if ($climate->arguments->defined('help')) {
    $climate->usage();
    exit(EX_SUCCESS);
}

// load configuration

$name = $climate->arguments->get('config');
$path = $config['base'] . '/' . $name;

if (! file_exists($path)) {
    $climate->to('error')->error("Config file '$name' could not be found!");
    exit(EX_CONFIG_NOT_FOUND);
}

try {
    $yaml = Yaml::parse(file_get_contents($path));
    $config = array_merge($yaml, $config);
} catch (ParseException $e) {
    $climate->to('error')->error('There was an error when parsing config file!');
    exit(EX_CONFIG_PARSING_ERROR);
}

$server = \Kelunik\AcmeClient\resolveServer($config['server']);
$dir = \Kelunik\AcmeClient\serverToKeyname($server);

$config['certs'] = $config['storage'] . '/certs/' . $dir;

// set environment variables

putenv('USER=' . $config['cpanel']['user']);
putenv('PASS=' . $config['cpanel']['password']);

// insert custom nameserver into 'acme issue' command
// find resolve command, insert or replace nameserver if defined, remove otherwise

$path = $config['base'] . '/vendor/kelunik/acme-client/src/Commands/Issue.php';
$search = '/(?<=\\\Amp\\\Dns\\\resolve\(\$domain, \[)(\s*)(?:"server" => ".*",\s*)?(?="types" =>)/';
$replace = '$1' . ($config['nameserver'] ? '"server" => "' . $config['nameserver'] . '",$1' : '');

$content = preg_replace($search, $replace, file_get_contents($path), -1, $count);

if (! $count) {
    $climate->to('error')->error("Could not replace nameserver used by 'acme issue' command.");
    exit(EX_NAMESERVER_HACK_ERROR);
}

file_put_contents($path, $content);

// setup the Command class

Command::$config = $config;
Command::$climate = $climate;

Command::$aliases = [
    'acme'  => [
        PHP_BINARY,
        $config['base'] . '/bin/acme',
    ],
    'sslic' => [
        PHP_BINARY,
        $config['base'] . '/vendor/neurobin/sslic/sslic.php',
    ],
];

Command::$defaults = [
    'acme' => [
        '--server'  => $config['server'],
        '--storage' => $config['storage'],
    ],
];

// register a certification account

Command::exec('acme', [
	'setup',
	'--email' => $config['email'],
]);

if (Command::$result != 0) {
    reportErrorAndExit('Failed to setup acme client');
}

// check, issue and setup certificates

$notifications = [];

foreach ((array) $config['certificates'] as $certificate) {

    // extract domain paths and names, we need to pass a path for every passed domain
    // to avoid mixing things up when issue command will use last path for remaining domains

    $domainsMap = [];

    foreach ((array) $certificate['domains'] as $path => $names) {
        foreach ((array) $names as $name) {
            $domainsMap[$name] = $config['home'] . $path;
        }
    }

    $domainNames = array_keys($domainsMap);
    $domainPaths = array_values($domainsMap);

    // skip if domains omitted in the certificates argument

    if ($certificates && ! array_intersect($domainNames, $certificates)) {
        continue;
    }

    // extract certificate meta

    if (! $domainNames) {
        $climate->to('error')->error('Invalid config, domains for certificate not defined');
        exit(EX_CONFIG_INVALID);
    }

    $name = $domainNames[0];
    $domains = implode(', ', $domainNames);

    $path = $config['certs'] . '/' . $name;

    $climate->info("Processing certificate $name ($domains)...");

    // check whether certificate should be renewed

	Command::exec('acme', [
        'check',
        '--name'  => $name,
        '--ttl'   => $config['renew'],
        '--names' => implode(',', $domainNames),
    ]);

    if (Command::$result == 255) {
        reportErrorAndExit("Error when checking certificate $name.");
    }

    // issue new certificate

    if (Command::$result == 0) {
        $climate->info("Certificate still valid for domains: $domains.");
    }
    else {
        Command::exec('acme', [
            'issue',
            '--domains' => implode(':', $domainNames),
            '--path'    => implode(':', $domainPaths),
            '--bits'    => $certificate['bits'],
        ]);

        if (Command::$result != 0) {
            removeDirectory($path);
            reportErrorAndExit("Error when issuing certificate $name.");
        }

        // remove challenge directories only when command succeeds

        foreach (array_unique($domainPaths) as $dir) {
            removeDirectory($dir . '/.well-known');
        }

        // ensure installation of newly issued certificate

        foreach (glob($path . '/installed.*') as $marker) {
            unlink($marker);
        }

        $climate->info(
            $notifications[] = "Certificate issued for domains: $domains."
        );
    }

    // install certificate in cpanel for corresponding domains without www prefix

    $installDomains = array_map(function ($domain) {
        return strtolower(substr($domain, 0, 4)) === 'www.' ? substr($domain, 4) : $domain;
    }, $domainNames);

    if (is_array($whitelist = $config['install']['whitelist'])) {
        $installDomains = array_intersect($installDomains, $whitelist);
    }

    if (is_array($blacklist = $config['install']['blacklist'])) {
        $installDomains = array_diff($installDomains, $blacklist);
    }

    $skippedDomains = [];
    $installedDomains = [];

    foreach (array_unique($installDomains) as $domain) {
        if (file_exists($path . '/installed.' . $domain)) {
            $skippedDomains[] = $domain;
            continue;
        }

        Command::exec('sslic', [
            $domain,
            $path . '/cert.pem',
            $path . '/key.pem',
            $path . '/chain.pem',
        ]);

        if (Command::$result != 0) {
            reportErrorAndExit('Error when installing certificate for ' . $domain);
        }

        $installedDomains[] = $domain;

        // prevent installing same certificate for same domain again in the future

        if (file_exists($path)) {
            touch($path . '/installed.' . $domain);
        }
    }

    if ($skippedDomains = implode(', ', $skippedDomains)) {
        $climate->info("Certificate already installed for domains: $skippedDomains.");
    }

    if ($installedDomains = implode(', ', $installedDomains)) {
        $climate->info(
            $notifications[] = "Certificate installed for domains: $installedDomains."
        );
    }
}

if ($notifications) {
    sendNotification('New certificates were issued and/or installed', implode(PHP_EOL, $notifications));
}
else {
    $climate->info('No certificates were issued and/or installed.');
}
